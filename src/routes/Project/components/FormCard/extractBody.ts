// This code was initially generated by ChatGPT on the 7th of June 2025.

import { ITextMap } from "./extractTranslations";

export type BodyNode = {
    tag: string;                  // input, select1, select, group, trigger
    ref?: string;                 // link to instance node
    appearance?: string | null;
    labelRef?: string | null; // reference to itext for label
    hintRef?: string | null; // reference to itext for hint
    labels?: Record<string, string> | null; // for label, can be multiple languages
    hints?: Record<string, string> | null; // for hint, can be multiple languages
    // itemLabels?: { value: string; labelRef?: string | null; labels?: Record<string, string> }[]; // improved structure
    items?: { labelRef: string; itemLabels?: Record<string, string>; value: string }[]; // updated items structure
    children?: BodyNode[];       // updated to use BodyNode instead of FormNode
}

function parseBodyElement(element: Element): BodyNode {
    const tag = element.tagName;
    const ref = element.getAttribute("ref") ?? undefined;
    const appearance = element.getAttribute("appearance") ?? null;
    let label: { [key: string]: string } | null = null; // corrected type for label
    let labelRef: string | null = null; // reference to itext for label
    // let label: { key: string: string | null } | null = null; // corrected type for label
    let hints: Record<string, string> | null = null; // updated to use hints
    let hintRef: string | null = null; // reference to itext for hint
    let items: { labelRef: string; itemLabels?: Record<string, string>; value: string }[] = []; // updated items structure

    Array.from(element.children).forEach(child => {
        if (child.tagName === "label") {
            const itextRef = child.getAttribute("ref");
            if (itextRef?.startsWith("jr:itext(")) {
                const match = itextRef.match(/jr:itext\('([^']+)'\)/);
                console.log("itextMatch", match);
                if (match && typeof match[1] === 'string') {
                    labelRef = match[1] ?? "";
                }
            } else {
                label = { 'en': child.textContent?.trim() ?? "" }; // fixed syntax for label
            }
        } else if (child.tagName === "hint") {
            const itextRef = child.getAttribute("ref");
            if (itextRef?.startsWith("jr:itext(")) {
                const match = itextRef.match(/jr:itext\('([^']+)'\)/);
                if (match && typeof match[1] === 'string') {
                    hintRef = match[1];
                }
            } else {
                hints = { 'en': child.textContent?.trim() ?? "" };
            }
        } else if (child.tagName === "item") {
            const itemLabelEl = child.querySelector("label");
            const itemValueEl = child.querySelector("value");
            if (itemLabelEl && itemValueEl) {
                let itemLabel = itemLabelEl.getAttribute("ref") ?? undefined;
                if (itemLabel?.startsWith("jr:itext(")) {
                    const match = itemLabel.match(/jr:itext\('([^']+)'\)/);
                    //     if (match) {
                    //         itemLabel = itexts[match[1]]?.["en"] ?? null;
                    //     }
                    // } else {
                    //     itemLabel = itemLabelEl.textContent?.trim() ?? undefined;
                    // }
                    const value = itemValueEl.textContent?.trim() ?? "";
                    items.push({ value, labelRef: match?.[1] ?? "", itemLabels: !itemLabelEl.getAttribute("ref") ? { "en": itemLabel ?? "" } : undefined }); // updated to match new structure
                }
            }
        }
    });

    // Recursively parse children for groups
    const children: BodyNode[] = [];
    if (tag === "group") {
        Array.from(element.children)
            .filter(e => ["group", "input", "select1", "select", "trigger"].includes(e.tagName))
            .forEach(child => {
                children.push(parseBodyElement(child));
            });
    }

    return {
        tag,
        ref,
        appearance,
        labels: label,
        hints: hints,
        items: items.length > 0 ? items : undefined,
        children: children.length > 0 ? children : undefined,
    };
}

export const extractBody = (xmlString: string): BodyNode[] => {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlString, "text/xml");

    const body = xmlDoc.querySelector("body");
    if (!body) return [];

    const result: BodyNode[] = [];

    Array.from(body.children).forEach(child => {
        result.push(parseBodyElement(child));
    });

    return result;
}
